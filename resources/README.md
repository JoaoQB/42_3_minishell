# Signals

### man sigaction

int sigaction(int signum, const struct sigaction *act,
					struct sigaction *oldact);

the sigaction() system call is used to change the action taken by a process on receipt of a specific signal.

signum specifies the signal and can be any valid signal except SIGKILL and SIGSTOP.
If act is non-NULL, the new action for signal signum is installed from act.
The sigaction structure is defined as something like:

struct	sigaction{
	void		(*sa_handler)(int);
	void		(*sa_sigaction)(int, siginfo_t *, void *);
	sigset_t	sa_mask;
	int			sa_flags;
	void		(*sa_restorer)(void);
};

sa_handler specifies the action to be associated with signum and is be one of the following:
	SIG_DFL - for the default action.
	SIG_IGN - to ignore this signal.
	a pointer to a siagnal handling function. This function recieves the signal number as it's only argument.

if SA_SIGINFO is specified in sa_flags, then sa_sigaction (instead os sa_handler) specifies the signal-handling for signum.

### man signal

sighandler_t signal(int signum, sighandler_t handler);

the behavior of signal() varies across UNIX versions, and has also varied historically across different versions of Linux.  Avoid its use: use sigaction(2) instead.

## What are Signals?

A signal is a notification process that an event has occurred. Signals are sometimes described as software interrupts.
The usual source of many signals sent to a process is the kernel. Among the types of events that cause the kernel to generate a signal for a process are the following:

	Hardware exception occured, meaning that the hardware detected a fault condition that was notified to the kernel, which in turn sent a corresponding signal to the process concerned.
	Examples of hardware exceptions include executing a malformed machine-language instruction, dividing by 0, or referencing a part of memory that is inaccessible.

	(!)The user typed one of the terminal special characters that generate signals. These characters include the interrupt character (Control-C) and the suspend character (Control-Z).

	A software event occurred. For example, input became available on a file descriptor, the terminal window was resized, a timer went off, process CPU time limit was exceeded, or a child process terminated.

Each signal is defined as a unique (small) integer. These integers are defined in <signal.h>, and have symbolic names of the form SIGxxxxx.
Because the actual numbers vary accross implementations, it is the symbolic names that are always used in programs. For example:
	│SIGINT    │       T        │ Terminal interrupt signal.  (Control-C)

	When the user types the terminal interrupt character (usually Control-C), the terminal driver sends this signal to the foreground process group. The default action is to terminate the process.

Upon delivery of a signal, a process carries out one of the following default actions, depending on that signal:

	The signal is ignored, that is, discarded by the kernel and has no effect on the process.

	The process is terminated (killed). Sometimes referred as abnormal process termination, as opposed to the normal process termination that occurs when a process terminates using exit().

	A core dump file is generated, and the process is terminated. A core dump file containts an image of the virtual memory of the process, which can be loaded into a debugger.

	The process is stopped, execution of the program is suspended.

	Execution of the process is resumed after previously being stopped.

Instead of accepting the default for a particular signal, a program can change the action that occurs when the signal is delivered. This is known as the disposition of the signal, and they can be:

	The default action should occur. This is useful to undo an earlier change of the disposition of the signal.

	The signal is ignored. This is useful for a signal whose default action would be to terminate the process.

	A signal handler is executed.

A signal handler is a function, written by the programmer, that performs appropriate tasks in responde to the delivery of a signal.

For example, the shell has a handler for the SIGINT signal (generated by the interrupt character, Control-C) that causes it to stop what it is currently doing and return control to the main input loop, so that the user is once more presented with the shell prompt.


Control-\ does nothing, so probably need to use SIG_IGN.

Control-D is not a signal. Instead, send an end-of-file (EOF) condition to the terminal.
In interactive programs like shells, this EOF condition is used to indicate the end of input.
Here's how Ctrl+D behaves in the context of terminal input:

	When you press Ctrl+D on an empty line, it signifies the end of input and typically causes the shell or other terminal-based program to exit.
	When you press Ctrl+D in the middle of a line, it signals the end of input for that particular line, but the program may continue to read more input afterward.

In our case pressing Ctrl+D in the beguinning of a line causes the program to exit to new line.

If cat then Ctrl+D exits to new line.
	jqueijo-@c1r16s15:~$ cat
	jqueijo-@c1r16s15:~$

If cat then type something and not press enter, first duplicates what was written and then new prompt in the same line.

	jqueijo-@c1r16s15:~$ cat
	123123jqueijo-@c1r16s15:~$

If on here_doc displays this message on beguinning of line:

jqueijo-@c1r16s15:~$ cat << EOF
>
bash: warning: here-document at line 7 delimited by end-of-file (wanted `EOF')
jqueijo-@c1r16s15:~$

If on here_doc and start to type but not press enter and then Ctrl+D, then it does nothing.

# First Pars

## Pipes

### ending in pipe

When doing `cmd |` (spaces after allowed e.g `cmd |   `), bash opens "here_doc".
```
jqueijo-@c2r10s6:~$ ls |
>
```
Waits for input (if pressed enter, new line, e.g.:)
```
ls |
>
>
```
When input is sent, checks if it doable, e.g.:
```
cd .. |
> ls
42-EXAM  Documents  eval     jqueijo-  Pictures   Public    snap       Videos
Desktop  Downloads  goinfre  Music     projectos  sgoinfre  Templates
```

or if not possible:
```
pwd |
> lol
Command 'lol' not found, did you mean:
```

In any case, when arrow is pressed, history becomes `cmd | cmd`.
Please note that spaces are kept. e.g.:

```
pwd |       '
> lol'

becomes
pwd |        lol'
```

```
pwd |'
>         lol'

becomes
'pwd |         lol'
```

```
pwd |'
> lol'

becomes
pwd | lol'
```

MIGHT NOT NEED TO HANDLE NOTHING AFTER PIPE, JUST DO SYNTAX ERROR

### after pipe

if pipe (`cmd | |`)

bash: syntax error near unexpected token `|'

if (cat | cat | cat | ls)
	waits for n eofs, n being number of cats.
