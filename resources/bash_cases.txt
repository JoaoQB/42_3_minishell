$PWD OR /home/jqueijo-
	bash: /home/jqueijo-: Is a directory
	mini: Is a directory

/notexisting
	bash: /notexisting: No such file or directory
	mini: No such file or directory

Folder without slash, like: Music
	bash: command not found
	mini: execve error reads : Permission denied

file names even if they exist:
	bash: command not found
	mini: command not found

./bugs.md (file exists but not executable)
	bash: permission denied
	mini: command not found







----------------------------------------------------------------------------------------------------

SIGNALS!!!

Control C
	In interactive mode:
		empty prompt: new prompt, exit status 130 --DONE
		stuff written: new prompt, exit status 130 (buffer should be clean too) --DONE
	after running a blocking command like cat without arguments: new prompt -- doing two prompts
	In here_doc: exits here_doc -- exiting program

Control D
	In interactive mode:
		in empty prompt: exit minishell -- DONE
		stuff written: do nothing -- DONE
	after running a blocking command like cat without arguments: default -- DONE
	In here_doc: exits heredoc with message: "heredoc ended by ^D (wanted $DELIM)" -- new prompt, missing message

Control \
	In interactive mode: ignored -- DONE
	In parent: "Quit (core dumped\n)" -- not doing anything
	In child: default
	In here_doc: ignored -- DONE

https://github.com/ahokcool/frankenshell/blob/main/docs/documentation.md#signals

----------------------------------------------------------------
ls > output.txt > input.txt Makefile
	cat Makefile > out.txt > out2.txt > out3.txt

	Cria primeiros dois ficheiros mas so 3 tem o cat do Makefile.

------------------------------------------------


	Makefile is an arg of ls.
	output.txt is created if it didn't exist.
	redirection is overwritten to input.txt
	output.txt is now empty.
	input.txt has Makefile written.

------------------------------------------------

echo "
Syntax Error

echo " ' " '
Syntax Error

echo " ' "
 '

echo ""
(new_line)

echo " ' " ' "
Syntax Error

When doing expansions, check case "foo"'$bar'

---------------------------------------------------

Variable Expansion

The ðŸ“–environment variable expansion works similar like in ðŸ”—bash.

	Variable Expansion happens if the variable is not inside single ðŸ“–quotes.
	Whitespaces inside the variable value will be marked as NO_SPACE characters (ðŸ“–). Therefore the ðŸ“–tokenizer can make multiple tokens out of it.
	If the variable is part of the ðŸ“–heredoc limiter it won't be expanded! (e.g. << $USER cat)

âœï¸ Examples
Command 		Valid Key 		Expand 		Output
echo $USER 			âœ… 			âœ… 			astein
echo "$USER" 		âœ… 			âœ… 			astein
echo '$USER' 		âœ… 			âŒ 			$USER
<< $USER cat 		N/A 		 âŒ 			Won't expand, so the EOF of the ðŸ“–heredoc will be $USER

âœï¸ Examples (Special Cases)
Special Case 		Valid Key 		Expand 		Explanation 										Output (example)
echo $@ hi 				âŒ 			âŒ 		first char of false key gets swallowed 					hi
echo $@@ hi 			âŒ 			âŒ 		first char of false key gets swallowed 					@ hi
echo $1HOME 			âŒ 			âŒ 		first char of false key gets swallowed 					HOME
$ 						âŒ 			âŒ 		no key 													$: command not found
echo $ hi 				âŒ 			âŒ 		no key 													$ hi
$? 						âŽ 			âœ… 		ðŸ“–exit status of the last command 						42: command not found
echo $? 				âŽ 			âœ… 		ðŸ“–exit status of the last command 						42
echo $?? 				âŽ 			âœ… 		ðŸ“–exit status of the last command 						42?
echo $"USER" 			âŒ 			âŒ 		the " block the key; contextual quotes get removed 		USER
echo "foo $'BAR'" 		âŒ 			âŒ 		the ' block the key; contextual quotes get removed 		foo $'BAR'
echo 'foo $"BAR"' 		N/A 		 âŒ 		 inside contextual quotes ' -> no expansion 			 foo $"BAR"
echo 'foo $BAR' 		N/A 		 âŒ 		 inside contextual quotes ' -> no expansion 			 foo $BAR
echo foo$USER$HOME 		âœ… âœ…		 âœ… âœ… 	  the second $ is not an allowed char of a key			  fooastein/home/astein
											therfore it terminates the first key.
echo foo $NOTEXIST bar 	âœ… 			âœ… 		the key doesn't exist; expands to NULL 					a b

------------------------------------------------------------

EXPORT

export VAR, actualiza export mas nao env.
export VAR= actualiza ambos

env imprime main_s.env
export imprime main_s.export

main_s comeÃ§a como env_sorted

Quando se actualiza export Ã© por ordem alfabetica,
quando se actualiza env Ã© cronologica.

Quando se faz export pode dar erro:
bash: export: `string': not a valid identifier

Se houver mais que um var ele faz set a todos.
